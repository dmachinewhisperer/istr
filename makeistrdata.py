#makeistrdata.py
"""
Process raw istr file and output istr data with length, hash and data bytes.
All istr definitions now come from input files only.

This script works with Python 2.6, 2.7, 3.3 and 3.4.
"""

from __future__ import print_function

import re
import sys

# Python 2/3 compatibility:
#   - iterating through bytes is different
#   - codepoint2name lives in a different module
import platform

if platform.python_version_tuple()[0] == "2":
    bytes_cons = lambda val, enc=None: bytearray(val)
    from htmlentitydefs import codepoint2name
elif platform.python_version_tuple()[0] == "3":
    bytes_cons = bytes
    from html.entities import codepoint2name
# end compatibility code

codepoint2name[ord("-")] = "hyphen"

# add some custom names to map characters that aren't in HTML
codepoint2name[ord(" ")] = "space"
codepoint2name[ord("'")] = "squot"
codepoint2name[ord(",")] = "comma"
codepoint2name[ord(".")] = "dot"
codepoint2name[ord(":")] = "colon"
codepoint2name[ord(";")] = "semicolon"
codepoint2name[ord("/")] = "slash"
codepoint2name[ord("%")] = "percent"
codepoint2name[ord("#")] = "hash"
codepoint2name[ord("(")] = "paren_open"
codepoint2name[ord(")")] = "paren_close"
codepoint2name[ord("[")] = "bracket_open"
codepoint2name[ord("]")] = "bracket_close"
codepoint2name[ord("{")] = "brace_open"
codepoint2name[ord("}")] = "brace_close"
codepoint2name[ord("*")] = "star"
codepoint2name[ord("!")] = "bang"
codepoint2name[ord("\\")] = "backslash"
codepoint2name[ord("+")] = "plus"
codepoint2name[ord("$")] = "dollar"
codepoint2name[ord("=")] = "equals"
codepoint2name[ord("?")] = "question"
codepoint2name[ord("@")] = "at_sign"
codepoint2name[ord("^")] = "caret"
codepoint2name[ord("|")] = "pipe"
codepoint2name[ord("~")] = "tilde"


# this must match the equivalent function in istr.c
def compute_hash(istr, bytes_hash):
    hash = 5381
    for b in istr:
        hash = (hash * 33) ^ b
    # Make sure that valid hash is never zero, zero means "hash not computed"
    # if bytes_hash is zero, assume a 16-bit mask (to match istr.c)
    return (hash & ((1 << (8 * (bytes_hash or 2))) - 1)) or 1


def istr_escape(qst):
    def esc_char(m):
        c = ord(m.group(0))
        try:
            name = codepoint2name[c]
        except KeyError:
            name = "0x%02x" % c
        return "_" + name + "_"

    return re.sub(r"[^A-Za-z0-9_]", esc_char, qst)


def parse_input_headers(infiles):
    qcfgs = {}
    istrs = {}

    # read the istrs in from the input files
    for infile in infiles:
        with open(infile, "rt") as f:
            for line in f:
                line = line.strip()

                # is this a config line?
                match = re.match(r"^QCFG\((.+), (.+)\)", line)
                if match:
                    value = match.group(2)
                    if value[0] == "(" and value[-1] == ")":
                        # strip parenthesis from config value
                        value = value[1:-1]
                    qcfgs[match.group(1)] = value
                    continue

                # is this a ISTR line?
                match = re.match(r"^Q\((.*)\)$", line)
                if not match:
                    continue

                # get the istr value
                istr = match.group(1)

                # special cases to specify control characters
                if istr == "\\n":
                    istr = "\n"
                elif istr == "\\r\\n":
                    istr = "\r\n"

                # work out the corresponding istr name
                ident = istr_escape(istr)

                # don't add duplicates
                if ident in istrs:
                    continue

                istrs[ident] = (ident, istr)

    if not qcfgs:
        sys.stderr.write("ERROR: Empty preprocessor output - check for errors above\n")
        sys.exit(1)

    return qcfgs, istrs


def escape_bytes(istr, qbytes):
    if all(32 <= ord(c) <= 126 and c != "\\" and c != '"' for c in istr):
        # istr is all printable ASCII so render it as-is (for easier debugging)
        return istr
    else:
        # istr contains non-printable codes so render entire thing as hex pairs
        return "".join(("\\x%02x" % b) for b in qbytes)


def make_bytes(cfg_bytes_len, cfg_bytes_hash, istr):
    qbytes = bytes_cons(istr, "utf8")
    qlen = len(qbytes)
    qhash = compute_hash(qbytes, cfg_bytes_hash)
    if qlen >= (1 << (8 * cfg_bytes_len)):
        print("istr is too long:", istr)
        assert False
    qdata = escape_bytes(istr, qbytes)
    return '%d, %d, "%s"' % (qhash, qlen, qdata)


def print_istr_data(qcfgs, istrs):
    # get config variables
    cfg_bytes_len = int(qcfgs["BYTES_IN_LEN"])
    cfg_bytes_hash = int(qcfgs["BYTES_IN_HASH"])

    # print out the starter of the generated C header file
    print("// This file was automatically generated by makeistrdata.py")
    print("")

    # add NULL istr with no hash or data
    print('ISTRDEF(ISTRnull, 0, 0, "")')

    # add all istrs sorted by their string value for consistent output
    for ident, istr in sorted(istrs.values(), key=lambda x: x[1]):
        qbytes = make_bytes(cfg_bytes_len, cfg_bytes_hash, istr)
        print("ISTRDEF(ISTR_%s, %s)" % (ident, qbytes))


def do_work(infiles):
    if not infiles:
        print("Usage: python makeistrdata.py <input_files...>")
        print("Input files should contain Q(...) definitions and QCFG(...) config lines")
        sys.exit(1)
    
    qcfgs, istrs = parse_input_headers(infiles)
    print_istr_data(qcfgs, istrs)


if __name__ == "__main__":
    do_work(sys.argv[1:])